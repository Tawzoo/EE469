// Test of CBZ and B instruction.
// Requires:
// ADDI, ADDS, SUB, CBZ, B.LT, B, LDUR, STUR
// Expected results:
// X0 = 0
// X1 = 8
// X2 = 4 (on pipelined CPU), or 0 (single-cycle CPU).
// X3 = 5
// X4 = 7
// X5 = 2
// X6 = -2
// X7 = -2  
// X8 = 0
// X9 = 1
// X10 = -4
// X14 = 5
// X15 = 8
// X16 = 9
// X17 = 1
// X18 = 99
// Mem[0] = 8
// Mem[8] = 5

//ADDI: I-type, Reg[Rd] = Reg[Rn] + {'0, Imm12}
//OP         Imm12        Rn    Rd
//3322222222 221111111111 00000 00000
//1098765432 109876543210 98765 43210
//1001000100 Unsigned     0..31 0..31

//B: B-type, PC = PC + SignExtend({Imm26, 2'b00})
//OP     Imm26
//332222 22222211111111110000000000
//109876 54321098765432109876543210
//000101 2's Comp Imm26

//CBZ: CB-type, if (R[Rt] == 0) PC = PC + SignExtend({Imm19, 2'b00})
//OP       Imm19               Rt
//33222222 2222111111111100000 00000
//10987654 3210987654321098765 43210
//10110100 2's Comp Imm19      0..31

//SUBS: R-type, Reg[Rd] = Reg[Rn] - Reg[Rm]
//OP          Rm    Shamt  Rn    Rd
//33222222222 21111 111111 00000 00000
//10987654321 09876 543210 98765 43210
//11101011000 0..31 000000 0..31 0..31

//ADDS: R-type, Reg[Rd] = Reg[Rn] + Reg[Rm]
//OP          Rm    Shamt  Rn    Rd
//33222222222 21111 111111 00000 00000
//10987654321 09876 543210 98765 43210
//10101011000 0..31 000000 0..31 0..31

//B.LT: CB-type, if (flags meet condition) PC = PC + SignExtend({Imm19, 2'b00})
//OP       Imm19               Cond
//33222222 2222111111111100000 00000
//10987654 3210987654321098765 43210
//01010100 2's Comp Imm19      01011

//LDUR: D-type, Reg[Rt] = Mem[Reg[Rn] + SignExtend(Imm9)]
//OP          Imm9      00 Rn    Rt
//33222222222 211111111 11 00000 00000
//10987654321 098765432 10 98765 43210
//11111000010 2's Comp  00 0..31 0..31

//STUR: D-type, Mem[Reg[Rn] + SignExtend(Imm9)] = Reg[Rt]
//OP          Imm9      00 Rn    Rt
//33222222222 211111111 11 00000 00000
//10987654321 098765432 10 98765 43210
//11111000000 2's Comp  00 0..31 0..31

               // MAIN:
1001000100_000000000000_11111_00000    // ADDI X0, X31, #0        // X0 = 0
1001000100_000000000000_11111_00001    // ADDI X1, X31, #0        // X1 = 0
1001000100_000000000000_11111_00010    // ADDI X2, X31, #0        // X2 = 0, counter of branch delay slots.
               // // Simple forwarding
1001000100_000000000101_11111_00011    // ADDI X3, X31, #5        // X3 = 5
1001000100_000000000010_00011_00100    // ADDI X4, X3, #2         // X4 = 7
11101011000_00011_000000_00100_00101   // SUBS X5, X4, X3         // X5 = 2
11101011000_00100_000000_00011_00110   // SUBS X6, X3, X4         // X6 = -2
11101011000_00100_000000_00011_00111   // SUBS X7, X3, X4         // X7 = -2  
               // // Forwarding and X31
1001000100_111111111111_11111_11111    // ADDI X31, X31, #-1      // Writing -1 to X31, but it should stay as 0
11101011000_11111_000000_00001_01000   // SUBS X8, X1, X31        // X8 = 0
11101011000_01000_000000_11111_01000   // SUBS X8, X31, X8        // X8 = 0
11101011000_11111_000000_01000_01000   // SUBS X8, X8, X31        // X8 = 0
11101011000_11111_000000_01000_01000   // SUBS X8, X8, X31        // X8 = 0
 
